# Overview

.NET Acquisition and deployment team will act as arbitrator and work in close liaison with Shared Framework owners. Team will own defining the guidelines to produce and consume a consistent shared framework across .NET Core product. This will greatly help in being proactive to the issues that may come up while composing the product and delivering it to the customers.
 
# Ownership: 
1. Identify, and report redundancy of  common assemblies carried in multiple Shared Frameworks.
2. Drive discussions among Technology owners, team doesn't own the decision or its delivery.
3. Define requirement and provide common tooling to produce Shared Framework and installers.
 
## Identify, and report redundancy of  common assemblies carried in multiple Shared Frameworks.
 
Shared framework is folder carrying .NET Core assemblies that are versioned and released together. A shared framework can exhibit dependency on another shared framework. For e.g. on Windows, these can be found under C:\program files\dotnet\shared\ . Shared framework has a name and version . .NET Core host will never run on a lower version, but it may try to run on a higher version

As of today,  .NET Core 3.0 has three shared frameworks planned :

Framework name	| Description
-------------- | -----------
Microsoft.NETCore.App | The base runtime. It supports things like System.Object, List<T>, string, memory management, file and network IO, threading, etc.
Microsoft.AspNetCore.App  |	The default web runtime. It imports Microsoft.NETCore.App, and adds API to build an HTTP server using Kestrel, Mvc, SignalR, Razor, and parts of EF Core.
~~Microsoft.AspNetCore.All~~  | ~~Integrations with third-party stuff. It imports Microsoft.AspNetCore.App.It adds support for EF Core + SQLite, extensions that use Redis, config from Azure Key Vault, and more. (Will be deprecated in 3.0.)~~
Microsoft.DesktopUI.App[.NET Core 3.0 release]  |  The default desktop runtime. It imports Microsoft.NETCore.App, and adds APIs to build WinForms and WPF applications.
 
*It is important to ensure that shared framework(s) exhibit right version dependency for a release. For e.g , Microsoft.DesktopUI.App and Microsoft.AspNetCore.App exhibit dependency on exact same version of Microsoft.NETCore.App.*
 
## Drive discussions among Technology owners, team doesn't own the decision or its delivery.
 
Report redundant assemblies and drive discussion & decision. These are the following decision options:
1. Introduce a middle layer shared framework that comprises of common assemblies
2. Move to lower level shared framework ,for e.g. Microsoft.NetCore.App 
3. Do not carry files in shared framework. Is there another means to consume these assemblies ?
*This implies that one or the other do work to avoid the dependency. They cannot do this if the types need to be exposed in public surface. They can if the types are only used by implementation (EG: by taking source code rather than dependency)*
4. Do nothing ?
   1. It is a possible solution so long shared frameworks are a single chain. For e.g. If DesktopUI and Core.App both have common dll then DesktopUI should win, since it’s clear that DesktopUI explicitly chose to carry it despite the file being present in its dependency.
   2. There is a risk around assembly-unification and deciding which copy of an overlapping DLL will win. For e.g if Microsoft.AspNeCore.App and Microsoft.DesktopUI.App carry foo.dll, then it’s not clear who should when the app loads it.
 
Defining a formula or questionnaire of some sort will help choose the optimal decision. This will intrinsically help define what comprises a shared framework .
  
## Define requirement and provide common tooling to produce Shared Framework and installers.
 
Ideally, all shared frameworks should be built by common tooling ( common Target ) or toolset.Technology owner should be able to acquire the common tooling and feed in required inputs to the tool to produce known and uniform set of shared framework assets
 
Inputs to build a shared framework : 
* Name
* Version
* Dependencies
* Target Framework Moniker (TFM)
* Runtime Identifiers (Rids) for Shared Framework
* Packages 
    * List of <id,version>
 * Assets for Shared Frameworks
    * Refs , docs, libs , native , resource
         > Should the packages be flattened in the resultant shared framework packages, or should it remain as a graph? Need to dig further to understand the impact.
*  Crossgen : Yes
   * crossgen tool
   * JIT
 
Output : 
* Shared Framework Installer / Zip
* Public Reference packages : 1 per shared framework
* Reference assemblies, XML docs , Platform manifest
* Public runtime packages :  n per shared framework, 1 per rid
* Crossgened assemblies
* Native libs
* Public language package installer : TBD ( Language pack story )
* Public language pack runtime package : TBD ( Language pack story ) 
  
Shared Framework installer carries the following : 
* Arch specific binaries ( everything in runtime package mentioned above)
* Deps file  ( computed )
* Runtime config ( computed )
* Setup assets
